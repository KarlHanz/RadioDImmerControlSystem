void loop() {
  //  startCheckErr();   // самопроверка на ошибки при первом запуске (перезагрузке) и обработчик ошибок
  brightLvl(); //автоподстройка яркости дисплея
  tacho(); //тахометр
  displayPrint();

  //============== *НОРМИРОВАНИЕ ==============

  powerDev = map(dimmer, 0, 255, 0, 100); // маппинг единиц диммера 0-255 к шкале 0-100% без НОРМИРОВАНИЯ

  dim.write(dimmer);  // значение диммирования принимает 0-255

  // ===============МАССИВ ДЛЯ ПЕРЕДАЧИ ТЕЛЕМЕТРИИ===============
  telemetry_data[0] = RPM;      //передаём точные обороты (0...2700) (которые потом сведутся к плавным фильтром среднего)
  telemetry_data[1] = powerDev; //возвращаем на дисплей значение мощности (0...100)
  telemetry_data[2] = relay;     //реле
  telemetry_data[3] = temp;     //температура
  telemetry_data[4] = statusCode;  //передаём цифровой код статуса (10,20,90)
  telemetry_data[5] = errorCode;  //передаём цифровой код ошибки (30,40,50,60,70)




  // ================РАДИО ПРИЕМ-ПЕРЕДАЧА================
  while (radio.available()) {  // до тех пор пока связь с блоком управления:
    radio.read(&recieved_data, sizeof(recieved_data) ); // Принимаем массив
    dimmerExt = recieved_data[0]; // принимаем внешнее значение диммирования (0...255)
    radio.writeAckPayload(1, &telemetry_data, sizeof(telemetry_data)); //отправка ответного пакета телеметрии
    previousMillis = millis();
  }

  if ((millis() - previousMillis) > 5000) { // Сброс переменной при разрыве связи. Работает только при значении >3000!!!
    radioCommState = 0;
  }

  // ================ ПРИ ПЕРВОМ ЗАПУСКЕ ПРОЦЕДУРА САМОПРОВЕРКИ НА РАБОТОСПОСОБНОСТЬ ================

  if (checkErrStart == 1 && ((millis() > 3000) && (millis() < 4000) && RPM <= 1000)) { //первое включение. ждём разгона до 1000 об за 4 сек.
    tachoFail = 1; // если не достигли нужных оборотов, ошибка тахо (либо не запустился мотор)
  } // ОШИБКА мотора или нет сигнала с тахометра (не подключен). [Выключить мотор: dimmer=0 и включить (разомкнуть) реле relay=1]

  if (checkErrStart == 1 && (millis() > 4000) && (millis() < 7000)) { //прошло более 4 сек после старта, включаю реле через 4 сек, даю +3 сек на разгон
    dimmer = 255;  // на максимум, но диммер не участвует сейчас
    relay = 1; // /включить (разомкнуть) реле //на дисплее DIMM, запуск через диммер
  } //флаг включения реле. Контакты размыкаются. Мотор разгоняется до максимума через диммер. Либо если контакты пригорели, мотор всё равно разгоняется

  if (checkErrStart == 1 && ((millis() > 7000) && (millis() < 9000) && RPM < 2000)) { //прошло более 7 сек после старта и обороты не достигли 2000
    dimmFail = 1;
  } // диммер плохо работает! [Включить мотор на полную через реле: dimmer=0, relay=0] Будет молотить бесконечно!

  if (checkErrStart == 1 && (millis() > 9000))  { ////Стартовые проверки завершены. Начинаем работать с принимаемым значением диммирования от блока управления либо работать сами по себе.
    checkErrStart = 0; //  Флаг старта обнуляем, если дошли до этого места. Ошибки не позволят дойти до сюда.

  }

  // ================ КОДЫ ОШИБОК и СТАТУСА ================
  if (checkErrStart == 1) statusCode = 10; //отправка статус кода 10 = "STARTING" на дисплей во время процедуры самопроверки вне зависимости от наличия связи
  if (checkErrStart == 0 && errorCode < 30 && radioCommState == 1) statusCode = 20; // для индикации "ONLINE" в зависимости от наличия связи. При отсутствии связи блок управления высветит внутреннюю ошибку OFFLINE
  if (errorCode >= 30) stateCode = errorCode; //при наличии ошибок высветить их
  if (errorCode < 30) stateCode = statusCode; //при отсутствии ошибок показывать либо RPM либо DONE


  // ================ УПРАВЛЕНИЕ ОБОРОТАМИ БЕЗ СВЯЗИ================
  if (checkErrStart != lastCheckErrStart && radioCommState == 0) { //Внутренняя программа после завершения старта, отсутствия ошибок, отсутствия связи на момент процедуры самопроверки
    if (checkErrStart == 0) { //для однократного срабатывания! //если старт завершен и нет связи:
      myTimer0.setTimeout(1000); //запуск таймера на выполнение дальнейшей программы
    }
    lastCheckErrStart = checkErrStart;
  }
  if (myTimer0.isReady()) { //выполнение основной программы отсюда
    relay = 0; //выключить (замкнуть) реле, включить мотор //на дисплее было бы LOAD
    dimmer = 255; // после срабатывания таймера обороты 2700
    myTimer1.setTimeout(10000);  // после срабатывания таймера запуск другого таймера на 10 мин
  }
  if (myTimer1.isReady()) {
    dimmer = 170; // после срабатывания таймера обороты 2200
    relay = 1; //включить (разомкнуть) реле //на дисплее было бы DIMM
    myTimer2.setTimeout(10000);  // после срабатывания таймера запуск другого таймера на 10 мин
  }
  if (myTimer2.isReady()) {
    dimmer = 100; // после срабатывания таймера обороты 1400
    myTimer3.setTimeout(10000);  // после срабатывания таймера запуск другого таймера на 10 мин
  }
  if (myTimer3.isReady()) {
    dimmer = 0; // после срабатывания таймера обороты выкл
    statusCode = 90; //высветить dOnE на внутреннем дисплее //не высвечивает!
  }


  // ================ УПРАВЛЕНИЕ ОБОРОТАМИ С НАЛИЧИЕМ СВЯЗИ================
  if (checkErrStart != lastCheckErrStart && radioCommState == 1) { //Внутренняя программа после завершения старта, отсутствия ошибок, наличия связи на момент процедуры самопроверки
    if (checkErrStart == 0) { //для однократного срабатывания! //если старт завершен и нет связи:
      dimmer = dimmerExt; // диммер на внешнее управление (по умолчанию связь есть, начальное значение переменной = 255)
    }
    lastCheckErrStart = checkErrStart;
  }



  // ================ УПРАВЛЕНИЕ ОБОРОТАМИ ПРИ ИЗМЕНЕНИИ СТАТУСА СВЯЗИ================
  if (radioCommState != lastRadioCommState && checkErrStart == 0 && errorCode < 30) { // сработает при изменении статуса связи. А при простом старте?
    if (radioCommState = 1) { //если связь появилась
      //   relay = 1; //включить (разомкнуть) реле //на дисплее DIMM
      dimmer = dimmerExt; // диммер на внешнее управление
    }
    if (radioCommState = 0) {//если связь пропала
      myTimer0.reset(); //перезапуск внутренней программы при отсутствии связи
    }
    lastRadioCommState = radioCommState;
  }



  // ================ ОБРАБОТЧИК ОШИБОК ================
  if (temp >= 60)  { //Постоянная проверка на превышение температуры. При значении 50 при жаре 30 срабатывает ошибка!
    tempFail = 1; //   Перегрев! Выключить реле, контакты замкнутся, диммер на отключение.
    dimmer = 0; //выключить диммер
    relay = 1; //включить (разомкнуть) реле, отключить мотор от сети (либо наоборот, отключить реле, пусть мотор работает)
  }
  else {
    tempFail = 0;
  }

  if (tachoFail == 1) { // НЕТ ОБОРОТОВ. [Выключить мотор: dimmer=0 и включить (разомкнуть) реле relay=1]
    dimmer = 0; //выключить диммер
    relay = 1; //разомкнуть реле, отключить мотор от сети
    checkErrStart = 0; // старт завершен
    errorCode = 30;
  }

  if (dimmFail == 1) {  //НЕ РЕГУЛИРУЮТСЯ ОБОРОТЫ. [Включить мотор на полную через реле: dimmer=0, relay=0]
    dimmer = 0; //выключить диммер
    relay = 0; //отключить реле, подключив мотор к сети
    checkErrStart = 0; // старт завершен
    errorCode = 40;
  }

  if (relayFail == 1) {  //реле не размыкается - контакты пригорели. Ошибка не мешает эксплуатации. Выключить диммер: dimmer=240, relay=0]
    dimmer = 0; //выключить диммер
    relay = 0; //отключить реле, подключив мотор к сети
    checkErrStart = 0; // старт завершен
    errorCode = 50;
  }

  if (tempFail == 1) { //[Выключить мотор: dimmer=0 и relay=1]
    dimmer = 0; //выключить диммер
    relay = 1; //разомкнуть реле, отключить мотор от сети
    checkErrStart = 0; // старт завершен
    errorCode = 60;
  }

  if (tempFail == 1 && (tachoFail == 1 || dimmFail == 1 || relayFail == 1)) { //отказ с перегревом!
    dimmer = 0; //выключить диммер
    relay = 1; //разомкнуть реле, отключить мотор от сети
    checkErrStart = 0; // старт завершен
    errorCode = 70;
  }

  //============== УПРАВЛЕНИЕ РЕЛЕ ==============
  digitalWrite(K1, relay); //  relay


  //============== УПРАВЛЕНИЕ ЯРКОСТЬЮ ==============
  brght = analogRead(Brg);







}
